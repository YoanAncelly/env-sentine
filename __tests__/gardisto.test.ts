import { handleResults } from '../src/gardisto';

// Generated by Qodo Gen

describe('handleResults', () => {

  // Function handles case with no errors and no warnings, displays success message
  it('should display success message when no errors or warnings exist', () => {
    const consoleSpy = jest.spyOn(console, 'log');
    handleResults([], [], 0);
    expect(consoleSpy).toHaveBeenCalledWith('No environment variable issues found.');
    consoleSpy.mockRestore();
  });

  // Function correctly displays multiple warnings with proper formatting
  it('should display formatted warnings when warnings array contains items', () => {
    const warnings = ['Warning 1', 'Warning 2'];
    const consoleSpy = jest.spyOn(console, 'warn');
    handleResults([], warnings, 0);
    expect(consoleSpy).toHaveBeenNthCalledWith(1, 'Warnings for environment variables:');
    expect(consoleSpy).toHaveBeenNthCalledWith(2, 'Warning 1\nWarning 2');
    consoleSpy.mockRestore();
  });

  // Function correctly displays multiple errors with proper formatting
  it('should display formatted errors when errors array contains items', () => {
    const errors = ['Error 1', 'Error 2'];
    const consoleSpy = jest.spyOn(console, 'error');
    const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => undefined as never);
    handleResults(errors, [], 2);
    expect(consoleSpy).toHaveBeenNthCalledWith(1, 'Errors found in environment variables:');
    expect(consoleSpy).toHaveBeenNthCalledWith(2, 'Error 1\nError 2');
    consoleSpy.mockRestore();
    mockExit.mockRestore();
  });

  // Function processes both errors and warnings arrays in the correct order
  it('should display warnings before errors when both exist', () => {
    const consoleWarnSpy = jest.spyOn(console, 'warn');
    const consoleErrorSpy = jest.spyOn(console, 'error');
    const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => undefined as never);
    handleResults(['Error'], ['Warning'], 1);
    expect(consoleWarnSpy).toHaveBeenCalled();
    expect(consoleErrorSpy).toHaveBeenCalled();
    consoleWarnSpy.mockRestore();
    consoleErrorSpy.mockRestore();
    mockExit.mockRestore();
  });

  // Error messages are truncated to first line only
  it('should truncate multi-line error messages to first line', () => {
    const consoleSpy = jest.spyOn(console, 'error');
    const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => undefined as never);
    const multilineError = 'First line\nSecond line\nThird line';
    handleResults([multilineError], [], 1);
    expect(consoleSpy).toHaveBeenCalledWith('First line');
    consoleSpy.mockRestore();
    mockExit.mockRestore();
  });

  // Handle empty arrays for both errors and warnings
  it('should handle empty arrays without throwing errors', () => {
    const consoleSpy = jest.spyOn(console, 'log');
    expect(() => handleResults([], [], 0)).not.toThrow();
    expect(consoleSpy).toHaveBeenCalledWith('No environment variable issues found.');
    consoleSpy.mockRestore();
  });

  // Handle non-string error/warning objects that need toString() conversion
  it('should convert non-string errors to strings using toString()', () => {
    const consoleSpy = jest.spyOn(console, 'error');
    const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => undefined as never);
    const errorObj = { message: 'Error message', toString: () => 'Error message' };
    handleResults([errorObj], [], 1);
    expect(consoleSpy).toHaveBeenCalledWith('Error message');
    consoleSpy.mockRestore();
    mockExit.mockRestore();
  });

  // Handle multi-line error/warning messages
  it('should handle multi-line warning messages correctly', () => {
    const consoleSpy = jest.spyOn(console, 'warn');
    const multilineWarning = 'Warning line 1\nWarning line 2';
    handleResults([], [multilineWarning], 0);
    expect(consoleSpy).toHaveBeenCalledWith('Warning line 1');
    consoleSpy.mockRestore();
  });

  // Handle extremely large arrays of errors/warnings
  it('should handle large arrays of errors without performance issues', () => {
    const consoleSpy = jest.spyOn(console, 'error');
    const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => undefined as never);
    const largeErrorArray = Array(1000).fill('Error message');
    const startTime = performance.now();
    handleResults(largeErrorArray, [], 1000);
    const endTime = performance.now();
    expect(endTime - startTime).toBeLessThan(1000);
    consoleSpy.mockRestore();
    mockExit.mockRestore();
  });

  // Process exits with code 1 when errors exist
  it('should exit process with code 1 when errors exist', () => {
    const mockExit = jest.spyOn(process, 'exit').mockImplementation(() => undefined as never);
    handleResults(['Error'], [], 1);
    expect(mockExit).toHaveBeenCalledWith(1);
    mockExit.mockRestore();
  });

  // Success message only shows when no warnings and no errors
  it('should not show success message when warnings exist without errors', () => {
    const consoleLogSpy = jest.spyOn(console, 'log');
    handleResults([], ['Warning'], 0);
    expect(consoleLogSpy).not.toHaveBeenCalledWith('No environment variable issues found.');
    consoleLogSpy.mockRestore();
  });
});
